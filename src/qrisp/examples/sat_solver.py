"""
\********************************************************************************
* Copyright (c) 2025 the Qrisp authors
*
* This program and the accompanying materials are made available under the
* terms of the Eclipse Public License 2.0 which is available at
* http://www.eclipse.org/legal/epl-2.0.
*
* This Source Code may also be made available under the following Secondary
* Licenses when the conditions for such availability set forth in the Eclipse
* Public License, v. 2.0 are satisfied: GNU General Public License, version 2
* with the GNU Classpath Exception which is
* available at https://www.gnu.org/software/classpath/license.html.
*
* SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
********************************************************************************/
"""


import numpy as np
import sympy as sp
from sympy.logic.utilities.dimacs import load
from qrisp import auto_uncompute, z, multi_measurement
from qrisp.grover import grovers_alg

# %%

# Load dimacs file into sympy logical expression
dimacs = """
c A SAT instance generated from a 3-CNF formula that had 20 clauses and 3 variables
p cnf 3 20
-3 1 -2 0
3 -1 2 0
-3 1 -2 0
1 -2 3 0
3 2 -1 0
3 2 -1 0
-2 -3 1 0
1 -3 -2 0
3 -1 -2 0
-1 2 3 0
-3 1 2 0
-1 2 3 0
2 3 -1 0
2 -1 3 0
-3 2 -1 0
-3 1 -2 0
3 2 -1 0
-3 -2 -1 0
-1 -3 -2 0
-3 -2 -1 0
"""
logical_expr = load(dimacs)

# %%


# This function simply inverts a bitstring ie. "0010" -> "1101"
def invert_bitstring(bs):
    res = ""
    for c in bs:
        if c == "0":
            res += "1"
        else:
            res += "0"
    return res


# Takes a logical sympy expression and a list of QuantumBools and evaluates the
# expression into a new QuantumBool. The QuantumBools need to have the same name as the
# Sympy symbol they are associated to.
def q_eval_bl_expression(expr, qbls):
    # If the expression is a symbol, simply return the associated QuantumBool
    if isinstance(expr, sp.Symbol):
        for qbl in qbls:
            if qbl.name == expr.name:
                return qbl
        else:
            raise Exception(f"Could not find {expr.name} in given QuantumBool list.")

    # Otherwise, prepare the list of arguments as QuantumBools
    from sympy import And, Not, Or

    qbools = []  # This list will contain the QuantumBools
    ctrl_state = ""  # This string will contain the control state of the
    # multi-controlled X-gate to perform the And/Or evaluation

    for arg in expr.args:
        if isinstance(arg, Not):
            subexpr = arg.args[0]
            ctrl_state += "0"
        else:
            subexpr = arg
            ctrl_state += "1"

        qbools.append(q_eval_bl_expression(subexpr, qbls))

    # Now evaluate the logic
    from qrisp import QuantumBool, mcx, x

    # Create result QuantumBool
    res = QuantumBool()

    if isinstance(expr, And):
        # In the case of "and" use multi-controlled X-gate
        mcx(qbools, res, ctrl_state=ctrl_state)
    elif isinstance(expr, Or):
        # In the case of "or" invert both input and output (De Morgan's law)
        mcx(qbools, res, ctrl_state=invert_bitstring(ctrl_state))
        x(res)
    else:
        raise Exception(f"Dont know how to handle type {type(expr)}")

    return res


# %%

# Test evaluation function

# Generate list of symbols appearing in the logical expression
free_symbols = list(logical_expr.free_symbols)

# Generate random input value constellation
test_input = []

for i in range(len(free_symbols)):
    if np.random.random() > 0.5:
        test_input.append(True)
    else:
        test_input.append(False)

# Create substitution dictionary
subs_dic = {free_symbols[i]: test_input[i] for i in range(len(free_symbols))}
# Evaluate logical expression via sympy
print("Sympy evaluation result: ", logical_expr.subs(subs_dic))


# Now evaluate via qrisp

from qrisp import QuantumBool

# Create list of QuantumBools
qbls = [QuantumBool(name=symb.name) for symb in free_symbols]

# Initiate truth values
for qbl in qbls:
    qbl[:] = subs_dic[sp.Symbol(qbl.name)]

# Call evaluation function
res_qbl = q_eval_bl_expression(logical_expr, qbls)

# Simulate
print("Qrisp evaluation result: ", res_qbl)

# %%

# Now create oracle function


# auto_uncompute uncomputes all local variables
@auto_uncompute
def oracle(input_qbls, logical_expr=None):
    # Evaluate logical expression
    temp = q_eval_bl_expression(logical_expr, qbls)

    # Perform phase tag
    z(temp)


# Check QuantumCircuit generated by the oracle function
qbls = [QuantumBool(name=symb.name) for symb in free_symbols]
oracle(qbls, logical_expr)

print(qbls[0].qs)

# %%

# Now evaluate Grovers algorithm

qbls = [QuantumBool(name=symb.name) for symb in free_symbols]

grovers_alg(qbls, oracle, kwargs={"logical_expr": logical_expr})

print(qbls[0].qs)

# %%

# Perform simulation

mes_res = multi_measurement(qbls)
print("Measurement outcome: ", mes_res)

sat_solution = list(mes_res)[0]
solution_subs_dic = {free_symbols[i]: sat_solution[i] for i in range(len(free_symbols))}
evaluated_expression = logical_expr.subs(solution_subs_dic)

print("Expression value: ", evaluated_expression)
